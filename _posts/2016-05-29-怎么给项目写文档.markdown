---
layout:     post
title:      "怎么写项目文档(一)"
subtitle:   "web"
date:       2016-05-29
author:     "樊晋龙"
header-img: "img/怎样.png"
tags:
    - web
---

<h2>{{ page.title }}</h2>

当然，这不是一篇教程。只是第一次写文档时候的粗浅心得。<br><br>
如果大学课设毕设也算的话，确实已经写过不少文档了。当然之前是为了应付考试，随便找了材料修修补补，也就交上去了，项目和文档都不是自己的。然而最近要交接工作，项目是一年来不断挖坑扩展
做出来的，说没有感情是假的，自然想好好写个文档，一方面是方便交接，一方面也是对过去一年大部分工作的总结。这自然就马虎不得了。<br><br>
自己的文档自己说了算，没有标题段落字数格式的限制，这才是真正的写文档。流于格式，又不是画画给人看……内容条理清晰才是王道啊。当然太过随意变成空间烂俗转发字体，故意恶心人也是不对的！<br><br>
后端获取数据的程序只是在部分计算方面写了些功能，主要内容比如多线程抓取各个表的内容实时更新，从redis补充应用数据等都是之前别人写的。只好从程序入口捋一捋，尽量把所有功能点的实现方式都列出来。
一个java后台程序怎么写文档呢？从服务器启动开始，监听了一个Listener类，类里面首先初始化配置文件，然后开启几个线程。每个线程对应一个继承了Runnabale的类，该类中的run方法即为功能点，或者
该类中还存在一个构造方法Run，构造方法中使用Timer的API对线程的执行频率进行了规定。基本模式都是一致的，只是业务逻辑不同而已。<br><br>
这样就清晰了！举个栗子讲讲吧，抓取用户数据的线程干了点啥？遍历配置文件读取的用户库中的用户表，组成个hashmap，再和本地库中的用户表对比，主键一致的更新，不一致的插入。听起来很简单，但涉及多线程
就必须谨慎了，插入和对比的读取操作都需要同步，保证互斥访问。最近一段时间项目中莫名其妙多出来的错误数据很有可能是多线程的锅，然而还没有找到bug的地方，并且不打算找了~之前自己写的时候用多线程callable接口，可以获取线程的返回状态，然而似乎并没有快多少，还没有来的及找原因就换方法了……然后就用一个标识位来判断多线程状态，指定最多10个线程，其实多的时候可以用到10几20个，虽然超出了，但同时标识变成false，就
不再增加线程了。目前项目中使用的多线程都是这种方式，肯定有更好的实现，留待我以后好好琢磨了。其实优化的地方很多，比如之前遍历全表组成哈希的方式，也并不是一个高效的方法。希望以后能接触的项目不仅仅是功能点的实现，关注底层才能不出大篓子……<br><br>
对这个后台程序做的东西其实并没有太多，比如从kafka获取数据，就完全是另一个程序了。完全没接触过，要了那个消费者的程序，研究完以后再补充！这个程序还调用了很多第三方的API，大部分没有
给sdk的服务商使用urlconnection的方式，获取返回的body，然后再writeline一行一行取到string中，再去解析。前两天写的一个springmvc的小项目还用封装好的http包来调，post方式就给一个form，把参数都添加的form中，get方式就直接在path参数里面写几个参数。感觉也很方便。这些都是细枝末节，能实现功能的代码就是好代码！不过更简单的实现肯定更受人喜欢了，吹牛逼也更方便哈哈。<br><br>
最后这个程序中比较多的就是各种计算量比较大的方法了，比如给用户评分的模块，涉及到基本上所有的业务表，然后一层一层的进行评分筛选，最后再组成一张分数表进行展示。当初头疼逻辑的时候也是非常烦躁，
所以优化肯定还是比较差劲。最后多线程跑分，勉强每天上班前能跑完，不过如果用户越来越多的话，或许就需要更好的实现方式了。程序员，不就是在不断挖坑和填坑的过程中成长的吗？哈哈，我感觉入行之后相比
之前在性格上多了一种优势，就是解决问题的执行力。遇到困难第一个想的是自己解决，靠别人终究是下策。即使有现成的解决方案，不是自己做的谁知道又会有什么隐秘的坑呢？<br><br>
后端项目其实也没有那么复杂，一切都是为了业务，那么就是为了业务的几张基本表而不断衍生各种服务。最后复杂到没法加新功能的时候，就可以重构了，哈哈。据说写文档可以避免这种事情的发生，不过谁说的来呢
？写的太复杂，反而也没人看了。该怎么瞎补瞎写还是怎么来。所以，搞好眼下的工作，后来的事儿留给时间吧！<br><br>
这是一个后端项目，之后我写完那个前端项目文档，再回来填坑！







<p>{{ page.date | date_to_string }}</p>